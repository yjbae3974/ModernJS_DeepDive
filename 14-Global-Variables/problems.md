## 전역변수의 위험성

-   전역 변수의 무분별한 사용은 위험하다.
-   반드시 사용할 이유를 찾지 못했다면 지역 변수를 사용해야 한다.

### 변수의 생명주기

-   `변수 호이스팅`을 통해, 변수 선언은 런타임 이전 단계에 실행된다.
-   그러나 엄밀히 말하자면, 이는 전역 변수에 한정된다.
-   지역변수는 함수가 호출될 때 생성되고, 함수가 종료될 때 소멸된다.
-   즉, `지역 변수`의 생명 주기는 `함수`의 생명 주기와 일치한다.
    -   이는, 자신이 등록된 스코프가 소멸될 때 까지 변수가 유효하다는 뜻이다.
-   스코프가 소멸되고 할당된 메모리 공간을 더이상 누구도 참조하지 않을 때,
    자바스크립트의 `가비지 컬렉터`가 이를 감지하여 메모리에서 해제한다.

```js
var x = "global";

function foo() {
    console.log(x); // undefined
    var x = "local";
}
foo();
```

-   위 예제에서, 함수 `foo`가 호출되면, 함수 몸체 내부의 `var x` 선언이 호이스팅되어, 함수 몸체 최상단으로 끌어올려진다.
-   따라서, `console.log(x)`는 `undefined`를 출력한다.

### 전역 변수의 문제점

-   암묵적 결합
    -   모든 코드가 전역 변수를 참조하고 할당할 수 있다.
    -   변수의 유효범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수도 있다.
-   긴 생명주기
    -   전역 변수는 애플리케이션이 종료될 때까지 메모리에 유지된다.
    -   따라서, 불필요한 메모리 사용이 발생할 수 있다.
    -   또한, `var`키워드로 선언된 전역변수는 언제든 재할당이 가능하므로, 의도치 않게 값이 변경될 수 있다.
-   스코프 체인 상에서 종점에 위치
    -   전역 변수는 스코프 체인 상에서 가장 마지막에 위치한다.
    -   따라서, 변수를 검색할 때 가장 마지막에 검색되므로, 성능 저하가 발생할 수 있다.
-   네임스페이스 오염
    -   js는 파일이 분리되어있어도 하나의 전역 스코프를 공유한다.
    -   따라서, 동일한 이름의 전역 변수를 선언하면, 의도치 않게 값이 변경될 수 있다.

## 전역 변수 사용을 억제하는 방법

1. 즉시 실행 함수
    - 모든 코드를 즉시 실행 함수로 감싸면, 함수 몸체 내부에 선언된 변수는 지역 변수가 된다.
2. 네임스페이스 객체
    - 전역 변수의 사용을 억제하기 위해, 전역 객체에 프로퍼티로 등록하는 방법이 있다.
3. 모듈 패턴
    - 모듈 패턴은 클로저를 기반으로 동작한다.
    - 지역 변수의 억제는 물론 캡슐화까지 구현할 수 있다.
    - 캡슐화: 객체의 state, behavior를 하나로 묶고, 외부로부터의 직접적인 접근을 제한하는 것.
    - 객체의 프로퍼티를 감출 목적으로 사용하기도 한다. 이를 정보 은닉이라고 한다.
4. ES6 모듈
    - ES6 모듈은 파일 자체가 모듈이 된다.
    - 파일 내에서 선언된 모든 변수는 지역 변수가 된다.
    - `export` 키워드를 사용하여, 외부로 공개할 변수, 함수, 클래스를 선택적으로 지정할 수 있다.
    - `import` 키워드를 사용하여, 다른 모듈에서 공개한 변수, 함수, 클래스를 사용할 수 있다.
    - ES6 모듈은 엄격 모드(`strict mode`)로 동작한다.
    - 따라서, 암묵적 전역 변수를 생성할 수 없다.
    - 파일 확장자 명으로는 `.mjs`를 권장한다.

## 몰랐던 것 📝

-   전역 변수의 무분별한 사용은 위험하며, 반드시 사용할 이유가 있을 때만 사용해야 한다
-   변수 호이스팅은 전역 변수에 한정되며, 지역 변수는 함수가 호출될 때 생성되고 종료될 때 소멸된다
-   전역 변수는 4가지 주요 문제점이 있다: 암묵적 결합, 긴 생명주기, 스코프 체인 종점 위치, 네임스페이스 오염
-   전역 변수 사용을 억제하는 방법이 4가지 있다: 즉시 실행 함수, 네임스페이스 객체, 모듈 패턴, ES6 모듈
-   ES6 모듈은 파일 자체가 모듈이 되며 엄격 모드로 동작한다
-   모듈 패턴은 클로저를 기반으로 캡슐화와 정보 은닉을 구현할 수 있다

## 기술 질문 대비 🤔

**Q: 전역 변수의 문제점은 무엇인가요?**<br />
A: 1) 암묵적 결합: 모든 코드가 전역 변수를 참조하고 할당할 수 있어 가독성이 떨어지고 의도치 않은 변경 가능, 2) 긴 생명주기: 애플리케이션 종료까지 메모리에 유지되어 불필요한 메모리 사용, 3) 스코프 체인 종점: 변수 검색 시 가장 마지막에 검색되어 성능 저하, 4) 네임스페이스 오염: 동일한 이름의 전역 변수로 인한 의도치 않은 값 변경

**Q: 전역 변수와 지역 변수의 생명주기 차이점은 무엇인가요?**<br />
A: 전역 변수는 애플리케이션이 종료될 때까지 메모리에 유지되지만, 지역 변수는 함수가 호출될 때 생성되고 함수가 종료될 때 소멸됩니다. 지역 변수의 생명주기는 함수의 생명주기와 일치합니다.

**Q: 전역 변수 사용을 억제하는 방법에는 어떤 것들이 있나요?**<br />
A: 1) 즉시 실행 함수: 모든 코드를 IIFE로 감싸서 지역 변수로 만들기, 2) 네임스페이스 객체: 전역 객체에 프로퍼티로 등록하기, 3) 모듈 패턴: 클로저를 기반으로 캡슐화 구현하기, 4) ES6 모듈: 파일 자체를 모듈로 만들어 지역 변수로 만들기

**Q: 모듈 패턴이란 무엇인가요?**<br />
A: 클로저를 기반으로 동작하는 패턴으로, 지역 변수의 억제는 물론 캡슐화까지 구현할 수 있습니다. 객체의 상태와 동작을 하나로 묶고 외부로부터의 직접적인 접근을 제한하여 정보 은닉을 구현할 수 있습니다.

**Q: ES6 모듈의 특징은 무엇인가요?**<br />
A: 파일 자체가 모듈이 되어 파일 내의 모든 변수가 지역 변수가 됩니다. export/import 키워드로 선택적 공개/사용이 가능하고, 엄격 모드로 동작하여 암묵적 전역 변수 생성을 방지합니다. .mjs 확장자를 권장합니다.

**Q: 다음 코드의 실행 결과를 설명해주세요.**<br />

```javascript
var x = 'global';
function foo() {
    console.log(x); // ?
    var x = 'local';
}
foo();
```
<br />
A: undefined가 출력됩니다. 함수 내부의 var x 선언이 호이스팅되어 함수 최상단으로 끌어올려지기 때문입니다. 지역 변수 x가 선언되었지만 아직 할당되지 않은 상태이므로 undefined가 출력됩니다.

**Q: 네임스페이스 오염이란 무엇인가요?**<br />
A: JavaScript는 파일이 분리되어 있어도 하나의 전역 스코프를 공유하므로, 동일한 이름의 전역 변수를 선언하면 의도치 않게 값이 변경될 수 있는 문제입니다. 이는 코드의 예측 가능성을 떨어뜨리고 버그를 발생시킬 수 있습니다.

**Q: 스코프 체인에서 전역 변수가 성능에 미치는 영향은 무엇인가요?**<br />
A: 전역 변수는 스코프 체인 상에서 가장 마지막에 위치하므로, 변수를 검색할 때 가장 마지막에 검색됩니다. 이는 변수 검색 시간을 늘려 성능 저하를 발생시킬 수 있습니다.

**Q: 암묵적 결합이란 무엇인가요?**<br />
A: 모든 코드가 전역 변수를 참조하고 할당할 수 있는 현상을 말합니다. 변수의 유효범위가 클수록 코드의 가독성이 나빠지고, 의도치 않게 상태가 변경될 수 있어 코드의 예측 가능성을 떨어뜨립니다.

**Q: 전역 변수를 사용해야 하는 경우는 언제인가요?**<br />
A: 반드시 사용할 이유가 있을 때만 사용해야 합니다. 예를 들어, 애플리케이션 전반에서 공유해야 하는 설정값이나 상태, 라이브러리의 진입점 함수 등이 있습니다. 하지만 가능한 한 지역 변수나 모듈 패턴을 사용하는 것이 좋습니다.

````
