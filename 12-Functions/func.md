## 서론

-   함수는 JS에서 가장 중요한 핵심 개념이다.
-   스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메서드, this, 프로토타입, 모듈화 등이 모두 함수와 깊은 관련이 있다.

```js
function add(x, y) {
    // x, y는 매개변수
    return x + y; // 반환값
}
add(2, 5); // 2,5는 인수
```

## 함수 사용 시 이점

-   코드 재사용
-   유지 보수 편의성 증가
-   코드 신뢰성 증가
-   적절한 네이밍 -> 코드 가독성 증가

### 함수 리터럴

-   함수는 객체이다.
-   객체를 객체 리터럴로 생성하는 것처럼, 함수도 함수 리터럴로 생성할 수 있다.

```js
const add = function (x, y) {
    // 익명 함수 리터럴
    return x + y;
};
```

-   함수는 객체지만 일반 객체와는 다르다.
    -   호출 가능하며, 함수 객체 고유의 `프로퍼티`를 가진다.

### 함수 정의 방법

1. 함수 선언문
    - 표현식과 달리, 이름 생략 불가
    - js엔진은 함수 이름과 동일한 식별자를 암묵적으로 생성. 거기에 함수 객체를 할당함.

```js
function add(x, y) {
    return x + y;
}
```

2. 함수 표현식
    - 함수는 일급 객체(값의 역할을 할 수 있는 객체)이므로, 변수에 할당 가능.
    - 함수 리터럴의 이름은 생략 가능(익명 함수)

```js
const add = function (x, y) {
    return x + y;
};
const sub = function subCannotCall(x, y) {
    // 기명 함수
    return x - y;
};
console.log(subCannotCall(5, 2)); // ReferenceError
```

3. Function 생성자 함수
    - 객체를 생성하는 `생성자 함수`로 선언
    - 클로저를 형성하지 않음
    - 고로 바람직하지 않음.

```js
const add = new Function("x", "y", "return x + y");
console.log(add(2, 5)); // 7
```

4. 화살표 함수(Arrow Function)
    - ES6에 도입된 함수 정의 방법
    - 기존 함수 표현식보다 간결하게 작성 가능
    - `this` 바인딩을 가지지 않기에, 메서드로 사용할 수 없음.
    - `prototype` 프로퍼티 없음.
    - `arguments` 객체 없음.

```js
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```

## 함수 호이스팅

-   아래 예제를 보자.

```js
console.log(add); // function add(x, y) { ... }
console.log(sub); // undefined

console.log(add(2, 5)); // 7
console.log(sub(5, 2)); // TypeError: sub is not a function
function add(x, y) {
    return x + y;
}
const sub = function (x, y) {
    return x - y;
};
```

-   모든 선언문이 그렇듯, 함수 선언문도 호이스팅된다.
-   함수 선언문은 런타임 이전에 함수 객체가 생성되어 식별자에 할당된다.
-   그러나 변수 호이스팅이랑은 다르다.
    -   변수는 선언과 초기화가 분리되어 있지만, 함수 선언문은 선언과 초기화가 동시에 이루어진다.

```js
console.log(x); // undefined
console.log(add(2, 5)); // 7
var x = 1;
function add(x, y) {
    return x + y;
}
```

-   함수 표현식은 변수 호이스팅과 동일하게 동작한다.
    -   변수에 할당된 함수 객체는 런타임 이전에 생성되지 않는다.
    -   따라서 함수 표현식은 함수 호이스팅이 발생하지 않는 것처럼 보인다.

### 그래서 둘 중 무엇이 더 권장되나?

-   JSON을 창안한 더글라스 크락포드는 `함수 표현식`을 사용할 것을 권장한다.
-   함수 선언문은 어디서든 호출할 수 있기 때문에, 코드의 흐름을 파악하기 어렵게 만들 수 있다.

## 함수 호출

-   매개 변수의 클로저는 함수 내부.
-   매개변수와 인수의 개수가 다르면?
    -   매개변수가 더 많으면, 없는 인수는 `undefined`로 초기화.
    -   인수가 더 많으면, 초과된 인수는 무시.

```js
function add(x, y) {
    return x + y;
}
console.log(add(2)); // NaN -> 2 + undefined
console.log(add(2, 5, 10)); // 7
```

-   매개변수는 순서에 의미가 있으므로, 이는 함수의 사용법을 어렵게 만든다.
-   따라서 매개변수가 3개 이상이면, 객체를 전달하는 방식을 권장한다.

```js
function createUser({ name, age, email }) {
    return {
        name,
        age,
        email,
    };
}
createUser({ name: "Alice", age: 30, email: "abcd@example.com" });
```

-   단, 인수로 전달된 객체는 `pass by reference`가 이루어지므로, 함수 내부에서 객체를 변경하면, 함수 외부에도 영향을 미친다.

### 반환

-   함수 호출은 표현식인데, 이는 return 키워드가 반환한 반환값으로 평가됨.
-   return 뒤에 아무것도 없으면, `undefined` 반환.
-   return문이 없으면, 함수 블록의 마지막 문까지 실행한 후, 암묵적으로 `undefined` 반환.

## Call by Value, Call by Reference

-   함수를 호출하면서 매개변수에 값을 전달하는 방식을 2가지로 구분
-   원시 값은 `Call by Value`, 객체는 `Call by Reference`가 이루어진다.
-   원시 값은 값 자체가 복사되어 전달되고, 객체는 참조 값이 복사되어 전달된다.
-   따라서 객체는 원본이 변경될 수 있다.
-   이를 방지할 수 있는 방법은?
    -   객체를 복사하여 전달하는 방법이 있다.
    -   `Deep Copy`를 통해 완전히 객체를 복사하여 보내는 방법이 있다.

### 즉시 실행 함수

-   형태에 주목하자.

```js
var total = (function (x, y) {
    return x + y;
})(2, 5);
console.log(total); // 7
```

### 콜백 함수

-   다른 함수의 내부로 전달되는 함수.
-   전달 받은 함수를 고차 함수(High Order Function) 라고 함.
-   콜백 함수는 나중에 호출되므로, 비동기 처리에 자주 사용됨.

```js
function greet(name, formatter) {
    return "Hello, " + formatter(name);
}
function upperCaseName(name) {
    return name.toUpperCase();
}
console.log(greet("Alice", upperCaseName)); // "Hello, ALICE"
console.log(
    greet("Bob", function (name) {
        // 익명 함수
        return name.toLowerCase();
    })
); // "Hello, bob"
```

-   이 외에도 map, filter, reduce 등의 배열 메서드에서 콜백 함수가 자주 사용됨.

## 순수 함수와 비순수 함수

-   순수 함수(Pure Function)
    -   동일한 인수를 전달하면, 항상 동일한 반환값을 반환.
    -   함수 외부의 상태를 변경하지 않음.
    -   부작용(Side Effect)이 없음.
    -   디버깅과 테스트가 용이하고, 코드의 신뢰성이 높아짐.
-   비순수 함수(Impure Function)
    -   동일한 인수를 전달해도, 다른 반환값을 반환할 수 있음.
    -   함수 외부의 상태를 변경할 수 있음.
    -   부작용이 있을 수 있음.
    -   디버깅과 테스트가 어려워지고, 코드의 신뢰성이 낮아짐.

```js
let count = 0; // 외부 상태
function increment() {
    // 비순수 함수
    count++; // 외부 상태에 의존, 외부 상태 변경.
}
function add(x, y) {
    // 순수 함수
    return x + y;
}
console.log(add(2, 5)); // 7
increment();
console.log(count); // 1
```

-   **함수형 프로그래밍**: 순수 함수의 사용을 장려하고, 부작용을 최소화하는 프로그래밍 패러다임.
-   함수형 프로그래밍에서는 상태와 가변 데이터를 피하고, 함수를 일급 객체로 취급하여 고차 함수를 활용함.
-   JS는 멀티 패러다임 언어이므로, 객체지향 프로그래밍 뿐만 아니라 함수형 프로그래밍을 적극적으로 활용중.

## 몰랐던 것 📝

-   함수는 JavaScript에서 가장 중요한 핵심 개념이며, 스코프, 클로저, this 등과 깊은 관련이 있다
-   함수는 객체이지만 일반 객체와 달리 호출 가능하고 고유 프로퍼티를 가진다
-   함수 정의 방법이 4가지나 있다 (선언문, 표현식, Function 생성자, 화살표 함수)
-   함수 선언문은 호이스팅되지만 함수 표현식은 변수 호이스팅과 동일하게 동작한다
-   더글라스 크락포드는 함수 표현식을 권장한다 (코드 흐름 파악의 어려움 때문)
-   매개변수가 3개 이상이면 객체를 전달하는 방식을 권장한다
-   원시 값은 Call by Value, 객체는 Call by Reference로 전달된다
-   순수 함수는 동일한 입력에 항상 동일한 출력을 반환하고 부작용이 없다

## 기술 질문 대비 🤔

**Q: 함수의 정의 방법에는 어떤 것들이 있나요?**<br />
A: 1) 함수 선언문(`function add() {}`), 2) 함수 표현식(`const add = function() {}`), 3) Function 생성자 함수(`new Function()`), 4) 화살표 함수(`() => {}`) 등 4가지 방법이 있습니다.

**Q: 함수 선언문과 함수 표현식의 호이스팅 차이점은 무엇인가요?**<br />
A: 함수 선언문은 런타임 이전에 함수 객체가 생성되어 식별자에 할당되므로 어디서든 호출 가능합니다. 함수 표현식은 변수 호이스팅과 동일하게 동작하여 선언 전에는 호출할 수 없습니다.

**Q: 더글라스 크락포드가 함수 표현식을 권장하는 이유는 무엇인가요?**<br />
A: 함수 선언문은 어디서든 호출할 수 있어 코드의 흐름을 파악하기 어렵게 만들기 때문입니다. 함수 표현식은 선언 후에만 호출 가능하여 코드의 가독성과 예측 가능성을 높입니다.

**Q: 매개변수가 많은 함수를 설계할 때 주의사항은 무엇인가요?**<br />
A: 매개변수가 3개 이상이면 객체를 전달하는 방식을 권장합니다. 매개변수는 순서에 의미가 있어 사용법을 어렵게 만들고, 객체 전달 방식은 순서에 상관없이 사용할 수 있습니다.

**Q: Call by Value와 Call by Reference의 차이점은 무엇인가요?**<br />
A: 원시 값은 Call by Value로 값 자체가 복사되어 전달되고, 객체는 Call by Reference로 참조 값이 복사되어 전달됩니다. 따라서 객체는 함수 내부에서 변경하면 원본이 변경됩니다.

**Q: 순수 함수와 비순수 함수의 차이점은 무엇인가요?**<br />
A: 순수 함수는 동일한 입력에 항상 동일한 출력을 반환하고 외부 상태를 변경하지 않습니다. 비순수 함수는 외부 상태에 의존하거나 외부 상태를 변경할 수 있어 부작용이 있을 수 있습니다.

**Q: 콜백 함수란 무엇인가요?**<br />
A: 다른 함수의 내부로 전달되는 함수를 말합니다. 전달받은 함수를 고차 함수라고 하며, 콜백 함수는 나중에 호출되므로 비동기 처리에 자주 사용됩니다.

**Q: 즉시 실행 함수(IIFE)의 특징과 사용 목적은 무엇인가요?**<br />
A: 함수를 정의하자마자 즉시 호출하는 함수입니다. 전역 스코프를 오염시키지 않고 모듈 패턴을 구현하거나, 복잡한 로직을 캡슐화할 때 사용됩니다.

**Q: 화살표 함수의 특징은 무엇인가요?**<br />
A: ES6에서 도입된 함수 정의 방법으로, 기존 함수 표현식보다 간결하게 작성할 수 있습니다. `this` 바인딩을 가지지 않아 메서드로 사용할 수 없고, `prototype` 프로퍼티와 `arguments` 객체가 없습니다.

**Q: 함수형 프로그래밍이란 무엇인가요?**<br />
A: 순수 함수의 사용을 장려하고 부작용을 최소화하는 프로그래밍 패러다임입니다. 상태와 가변 데이터를 피하고, 함수를 일급 객체로 취급하여 고차 함수를 활용합니다.
