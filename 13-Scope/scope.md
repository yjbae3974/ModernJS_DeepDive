## 스코프란?

-   모든 프로그래밍 언어의 기본적이며 중요한 개념임.
-   다른 언어와 구별되는 js의 고유한 특징도 있음.
-   `var`, `let`, `const`로 선언한 변수의 스코프도 다르게 동작한다.
-   모든 식별자(함수 이름, 클래스 이름 등)은 자신이 선언된 위치에 의해 다른 코드가 자신을 참조할 수 있는 **유효 범위**, 즉 **스코프**가 결정됨.

```js
var x = "global";

function foo() {
    var x = "local";
    console.log(x); // 'local'
}

foo();
console.log(x); // 'global'
```

-   함수 내에서 선언된 변수 x는 함수 외부에서 선언된 변수 x와 다른 변수임.
-   이름이 같은 2개의 변수 중에 어떤 변수를 참조할지 결정(identifier resolution)하는 규칙이 있음.
-   js 엔진은 코드를 실행할 때 코드의 context를 파악하고, 식별자를 검색할 때 현재 컨텍스트에서부터 시작하여 상위 컨텍스트로 올라가면서 검색함.

### Lexical Environment

-   '**코드가 어디서 실행되며 주변에 어떤 코드가 있는지**' 를 나타내는 개념.

### 다시 var, let, const의 차이점을 살펴보자.

-   `var`로 선언한 변수는 `같은 스코프` 내에서 중복 선언이 가능.
-   `let`, `const`로 선언한 변수는 `같은 스코프` 내에서 중복 선언이 불가능.

### 지역과 지역 스코프

-   지역이란, 함수 몸체 내부를 말함.
-   `지역 변수`는, 자신의 `지역 스코프`와 `하위 지역 스코프`에서 유효함.

## 스코프 체인

-   함수의 중첩: 함수 몸체 내부에 함수 정의.
    -   내부에서 정의된 함수: `nested function`, `inner function`, `중첩 함수`
    -   외부에서 정의된 함수: `outer function`, `외부 함수`
-   모든 스코프는 하나의 계층적 구조로 연결되며, 모든 지역 스코프의 최상위 스코프는 전역 스코프임.
-   스코프 체인은 물리적으로 존재. 변수가 선언되면 변수 식별자가 렉시컬 환경에 `키`로 등록. 변수 할당이 일어나면 변수 식별자에 해방하는 `값`을 변경.

## 함수 레벨 스코프

-   C, Java와 같은 대부분의 프로그래밍 언어는 블록 레벨 스코프를 지원.
-   아까 지역은, 함수 몸체 내부를 말하고, 지역은 지역 스코프를 만든다고 언급했음.
-   고로, js는 코드 블록이 아닌 함수만이 지역 스코프를 만듦.

```js
var x = 1;

if (true) {
    var x = 10;
}

console.log(x); // 10
```

-   if문 코드 블록 내에서 선언된 변수 x는, if문 코드 블록 밖에서 선언된 변수 x와 같은 변수임.
-   var 키워드로 선언된 변수는 `함수 레벨 스코프`만 인정하므로, 둘 다 `전역 변수`임.
-   아래는 C언어와 중대하게 동작이 다른 예제이다.

```c
int i = 10;
for(int i = 0; i < 5; i++){
    printf("%d\n", i);
}
printf("%d\n", i); // 10
```

```js
var i = 10;
for (var i = 0; i < 5; i++) {
    console.log(i);
}
console.log(i); // 5
```

-   그러나 ES6에서 도입된 `let`, `const` 키워드로 선언한 변수는 블록 레벨 스코프를 지원.

```js
let i = 10;
for (let i = 0; i < 5; i++) {
    console.log(i);
}
console.log(i); // 10
```

## Lexical Scope

```js
var x = 1;

function foo() {
    var x = 10;
    bar();
}
function bar() {
    console.log(x);
}
foo(); // ?
bar(); // ?
```

-   위 예제의 실행결과는 아래 2가지 가정에 따라 결정된다.
    -   함수를 어디서 `호출`했는지에 따라 함수의 상위 스코프가 결정된다.
    -   함수를 어디서 `정의`했는지에 따라 함수의 상위 스코프가 결정된다.
-   만약 첫번째라면, `foo()`의 실행결과는 `10`, `bar()`의 실행결과는 `1`이 될 것임.
-   그러나 js는 두번째 가정, 즉 함수를 어디서 `정의`했는지에 따라 함수의 상위 스코프가 결정됨.
-   따라서 `foo()`의 실행결과는 `1`, `bar()`의 실행결과는 `1`이 됨.

### 함수의 상위 스코프는 언제나 자신이 정의된 스코프이다.

## 몰랐던 것 📝

-   스코프는 식별자가 유효한 범위로, 모든 식별자는 자신이 선언된 위치에 의해 유효 범위가 결정된다
-   JavaScript는 함수 레벨 스코프를 지원하지만, ES6의 let/const는 블록 레벨 스코프를 지원한다
-   var로 선언한 변수는 같은 스코프 내에서 중복 선언이 가능하지만, let/const는 불가능하다
-   스코프 체인은 물리적으로 존재하며, 변수 검색 시 현재 스코프에서 상위 스코프로 올라가며 검색한다
-   JavaScript는 렉시컬 스코프를 따르므로 함수의 상위 스코프는 함수가 정의된 위치에 따라 결정된다
-   함수 호출 위치가 아닌 함수 정의 위치에 따라 스코프가 결정된다

## 기술 질문 대비 🤔

**Q: 스코프란 무엇인가요?**<br />
A: 스코프는 식별자가 유효한 범위를 말합니다. 모든 식별자(변수, 함수, 클래스 등)는 자신이 선언된 위치에 의해 다른 코드가 자신을 참조할 수 있는 유효 범위가 결정됩니다.

**Q: 함수 레벨 스코프와 블록 레벨 스코프의 차이점은 무엇인가요?**<br />
A: 함수 레벨 스코프는 함수만이 지역 스코프를 만드는 것이고, 블록 레벨 스코프는 코드 블록({})이 지역 스코프를 만드는 것입니다. var는 함수 레벨 스코프만 지원하고, let/const는 블록 레벨 스코프를 지원합니다.

**Q: var, let, const의 스코프 차이점은 무엇인가요?**<br />
A: var는 함수 레벨 스코프만 지원하고 같은 스코프 내에서 중복 선언이 가능합니다. let/const는 블록 레벨 스코프를 지원하고 같은 스코프 내에서 중복 선언이 불가능합니다.

**Q: 스코프 체인이란 무엇인가요?**<br />
A: 모든 스코프가 하나의 계층적 구조로 연결된 것을 말합니다. 변수를 참조할 때 현재 스코프에서 시작하여 상위 스코프로 올라가면서 변수를 검색하는 과정입니다.

**Q: 렉시컬 스코프란 무엇인가요?**<br />
A: 함수의 상위 스코프가 함수가 정의된 위치에 따라 결정되는 것을 말합니다. 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위 스코프가 결정됩니다.

**Q: 다음 코드의 실행 결과를 설명해주세요.**<br />

```js
var x = 1;
function foo() {
    var x = 10;
    bar();
}
function bar() {
    console.log(x);
}
foo(); // ?
bar(); // ?
```

<br />
A: 둘 다 1이 출력됩니다. JavaScript는 렉시컬 스코프를 따르므로 bar 함수의 상위 스코프는 bar가 정의된 전역 스코프입니다. foo 함수 내부에서 호출되어도 bar의 상위 스코프는 변하지 않습니다.

**Q: var와 let/const의 for 루프에서의 차이점은 무엇인가요?**<br />
A: var로 선언한 변수는 for 루프의 블록 스코프를 무시하므로 루프 후에도 변수에 접근할 수 있습니다. let/const로 선언한 변수는 블록 스코프를 인정하므로 루프 블록 외부에서는 접근할 수 없습니다.

**Q: 전역 스코프와 지역 스코프의 차이점은 무엇인가요?**<br />
A: 전역 스코프는 코드의 가장 바깥쪽 스코프로 어디서든 접근 가능합니다. 지역 스코프는 함수 내부에서 생성되는 스코프로 해당 함수와 그 하위 스코프에서만 접근 가능합니다.

**Q: 스코프 체인에서 변수를 찾지 못하면 어떻게 되나요?**<br />
A: 스코프 체인을 따라 전역 스코프까지 올라가서도 변수를 찾지 못하면 ReferenceError가 발생합니다. 이는 식별자를 찾을 수 없다는 의미입니다.

**Q: 중첩 함수에서 외부 함수의 변수에 접근할 수 있는 이유는 무엇인가요?**<br />
A: 스코프 체인 때문입니다. 내부 함수는 자신의 스코프와 외부 함수의 스코프, 그리고 전역 스코프에 모두 접근할 수 있습니다. 변수 검색 시 현재 스코프에서 시작하여 상위 스코프로 올라가며 검색하기 때문입니다.

````
