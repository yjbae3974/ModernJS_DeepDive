## 데이터 타입

-   js의 데이터 타입은 원시 타입(Primitive)과 객체 타입(Object)으로 나뉨.
-   원시 타입: number, string, boolean, null, undefined, symbol(ES6)
-   객체 타입: object, array, function
-   그래서 이 둘은 무슨 근본적인 차이가 있는가?

### 원시타입은 변경 불가능한 값(immutable value)이다.

-   원시 값을 변수에 할당하면, 변수에는 실제 값이 저장됨.
-   원시 값을 가지는 변수를 다른 변수에 할당하면, 실제 값이 복사되어 전달됨.
-   이를 pass by value라고 함.

### 객체는 변경 가능한 값(mutable value)이다.

-   객체를 변수에 할당하면, 변수에는 객체의 참조(reference)가 저장됨.
-   객체를 가지는 변수를 다른 변수에 할당하면, 객체의 참조가 복사되어 전달됨.
-   이를 pass by reference라고 함.

### 원시 값은 변경 불가능하다.

-   원시값을 직접 변경할 수 없다.
-   원시 값을 할당한 변수에 새로운 원시값을 재할당한다고 가정하자.
    -   메모리에 저장되어있는 원시값을 변경하는게 아니다.
    -   변수에 새로운 원시값이 저장된 메모리 주소를 할당하는 것이다.

### 왜 이렇게 하는가?

-   이러한 특성을 **불변성**이라고 한다.
-   불변성은 프로그램의 예측 가능성을 높여준다

```js
var str = "Hello";
str = "World"; // 메모리 공간에 새로운 'World'가 생성되고, str은 이를 가리키게 된다.
```

-   문자열의 한 문자를 변경하면 어떻게 되는가?

```js
var str = "Hello";
str[0] = "h"; // 아무런 효과가 없다.
console.log(str); // 'Hello'
```

-   문자열은 읽기 전용으로 불변이므로, str[0]을 변경할 수 없다.
-   예기치 못한 변경으로부터 자유로우므로, 이는 데이터의 신뢰성을 보장한다.

### 값에 의한 전달

```js
var a = 10;
var b = a; // a의 값 10이 복사되어 b에 전달됨.
b = 20; // b에 새로운 값 20이 할당됨.
console.log(a); // 10
console.log(b); // 20
```

-   `var b = a`에서 a의 값 10이 `복사`되어 b에 전달됨.
-   값 10을 복사했기 때문에, a와 b는 서로 독립적임.

## 객체

### 객체의 가장 큰 특징

-   프로퍼티 개수가 정해져있지 않다.
-   따라서 확보해야 할 메모리 공간의 크기를 미리 알 수 없다.
-   객체에 따라 크기가 매우 클 수 있다.

### C++, Java와의 차이는?

-   C++, Java는 객체를 생성할 때, class에 정의된 프로퍼티 개수와 타입에 따라 메모리 공간이 미리 할당된다.
-   이후에 프로퍼티를 삭제하거나 추가할 수 없는 방식이다.
-   다만 js는 객체 리터럴로 객체를 생성할 때, 프로퍼티를 미리 정의할 수 있지만, 이후에 프로퍼티를 추가하거나 삭제할 수 있다.
-   `class`가 굳이 필요 없기도 하다.

### 변경 가능한 값

```js
var obj1 = { name: "Alice" };
```

-   obj1에는 생성된 객체가 저장된 메모리 주소가 저장됨.
-   객체 값이 변경되면, 새로운 객체를 생성하는게 아니라, 기존 객체의 프로퍼티 값이 변경됨.

-   이는 객체를 복사하여 생성하는 비용이 크고, 크기가 일정하지도 않기에 어느정도 구조적 단점을 감안하여 만든 구조임.

-   따라서 여러 개의 식별자가 하나의 객체를 공유할 수 있다.

```js
var obj1 = { name: "Alice" };
var obj2 = obj1; // obj1이 가리키는 객체의 참조가 obj2에 복사되어 전달됨.
obj2.name = "Bob"; // obj2가 가리키는 객체의 name 프로퍼티 값을 변경함.
console.log(obj1.name); // 'Bob'
console.log(obj2.name); // 'Bob'
```

### Deep Copy vs Shallow Copy

-   객체를 복사할 때, 객체가 참조하는 다른 객체까지 모두 복사하는 것을 `Deep Copy`라고 한다.
-   객체가 참조하는 다른 객체는 복사하지 않고, 참조만 복사하는 것을 `Shallow Copy`라고 한다.
-   객체 안에 있는 객체에 대해서, 참조 값만 복사하는게 `Shallow Copy`이다.
-   js에서는 객체를 복사할 때, 기본적으로 `Shallow Copy`가 이루어진다.

```js
const o = { x: { y: 1 } };
const c1 = { ...o }; // Shallow Copy
console.log(c1 === o); //false
console.log(c1.x === o.x); //true
const c2 = JSON.parse(JSON.stringify(o)); // Deep Copy
console.log(c2 === o); //false
console.log(c2.x === o.x); //false
```

### Deep Copy vs Shallow Copy vs Pass by Reference

```js
const o = { x: { y: 1 } };
const c1 = { ...o }; // Shallow Copy
console.log(c1 === o); //false
console.log(c1.x === o.x); //true
const c2 = JSON.parse(JSON.stringify(o)); // Deep Copy
console.log(c2 === o); //false
console.log(c2.x === o.x); //false
const c3 = o; // Pass by Reference
console.log(c3 === o); //true
console.log(c3.x === o.x); //true
```

-   Pass by Reference는, 객체의 참조를 복사하여 전달하는 것이다.
-   따라서 c3와 o는 `동일한` 객체를 가리킨다.
-   이는 shallow도, deep도 아니다.

### 왜 false가 나오는가?(예제)

```js
var person1 = { name: "Alice" };
var person2 = { name: "Alice" };
console.log(person1 === person2); // false
```

-   `===`인 일치 비교 연산자는, 변수에 저장되어있는 값을 타입변환하지 않고 비교한다.
-   서로 다른 객체를 가리키므로, `===`은 참조 값을 비교하게 되고, `false`가 반환된다.

```js
console.log(person1.name === person2.name); // true
```

-   프로퍼티 값은 `원시 값`이므로, 실제 값을 비교하게 되고, `true`가 반환된다.

## 몰랐던 것 📝

-   원시 타입은 변경 불가능한 값(immutable value)이고 값에 의한 전달을 한다
-   객체 타입은 변경 가능한 값(mutable value)이고 참조에 의한 전달을 한다
-   원시 값을 재할당해도 기존 값을 변경하는 것이 아니라 새로운 메모리 공간에 값을 저장한다
-   문자열의 개별 문자는 변경할 수 없어 읽기 전용이다
-   객체는 프로퍼티 개수가 정해져 있지 않아 메모리 공간 크기를 미리 알 수 없다
-   여러 식별자가 하나의 객체를 공유할 수 있어 한쪽에서 변경하면 다른 쪽도 영향을 받는다
-   Deep Copy는 중첩된 객체까지 모두 복사하고, Shallow Copy는 참조만 복사한다
-   객체 비교 시 `===`는 참조 값을 비교하므로 내용이 같아도 false가 반환된다

## 기술 질문 대비 🤔

**Q: 원시 타입과 객체 타입의 근본적인 차이점은 무엇인가요?**<br />
A: 원시 타입은 변경 불가능한 값(immutable)이고 값에 의한 전달을 하며, 객체 타입은 변경 가능한 값(mutable)이고 참조에 의한 전달을 합니다. 원시 타입은 실제 값이 저장되고, 객체 타입은 참조가 저장됩니다.

**Q: 값에 의한 전달과 참조에 의한 전달의 차이점은 무엇인가요?**<br />
A: 값에 의한 전달은 실제 값을 복사하여 전달하므로 서로 독립적입니다. 참조에 의한 전달은 객체의 참조를 복사하여 전달하므로 여러 변수가 같은 객체를 공유합니다.

**Q: 원시 값이 변경 불가능하다는 것은 무엇을 의미하나요?**<br />
A: 원시 값을 직접 변경할 수 없다는 의미입니다. 변수에 새로운 값을 재할당해도 기존 값을 변경하는 것이 아니라 새로운 메모리 공간에 값을 저장하고 변수가 이를 가리키게 됩니다.

**Q: 문자열의 개별 문자를 변경할 수 없는 이유는 무엇인가요?**<br />
A: 문자열은 읽기 전용으로 불변(immutable)이기 때문입니다. 이는 데이터의 신뢰성을 보장하고 예기치 못한 변경으로부터 자유롭게 해줍니다.

**Q: Deep Copy와 Shallow Copy의 차이점은 무엇인가요?**<br />
A: Deep Copy는 객체가 참조하는 다른 객체까지 모두 복사하는 것이고, Shallow Copy는 참조만 복사하는 것입니다. JavaScript에서는 기본적으로 Shallow Copy가 이루어집니다.

**Q: 객체 비교 시 `===` 연산자가 false를 반환하는 이유는 무엇인가요?**<br />
A: `===` 연산자는 참조 값을 비교하기 때문입니다. 내용이 같아도 서로 다른 객체를 가리키면 false가 반환됩니다. 프로퍼티 값을 비교하려면 `person1.name === person2.name`처럼 개별 프로퍼티를 비교해야 합니다.

**Q: 객체의 구조적 단점을 감안한 이유는 무엇인가요?**<br />
A: 객체를 복사하여 생성하는 비용이 크고, 크기가 일정하지 않기 때문입니다. 따라서 여러 식별자가 하나의 객체를 공유할 수 있도록 설계되었습니다.

**Q: C++, Java와 JavaScript의 객체 생성 방식의 차이점은 무엇인가요?**<br />
A: C++, Java는 클래스에 정의된 프로퍼티에 따라 메모리가 미리 할당되고 이후 프로퍼티를 추가/삭제할 수 없습니다. JavaScript는 객체 생성 후에도 프로퍼티를 동적으로 추가/삭제할 수 있습니다.
